#!/usr/bin/env perl
# --- twitter > followingers
use strict; use warnings;

use Net::OAuth;
$Net::OAuth::PROTOCOL_VERSION = Net::OAuth::PROTOCOL_VERSION_1_0A;
use HTTP::Request::Common;
use LWP::UserAgent;
use URI::QueryParam;
use Data::Dumper;
use Carp qw( confess );
$SIG{__DIE__} =  \&confess;
use JSON;
use feature qw(switch);
use lib qw(lib);
use env;
use Schema;
use Verbose; $kVerbose = $ENV{'VERBOSE'} || 0;

my $UserAgent = 'curated-tag-feed';

=notes
    request_url => 'https://api.twitter.com/oauth/request_token',
    Access token URL: https://api.twitter.com/oauth/access_token
    Authorize URL: https://api.twitter.com/oauth/authorize
=cut

sub main {
    die "No curated-twitter given" if !$ARGV[0];
    my $curated_feed = Model::CuratedFeed->find({ twitter_account => $ARGV[0]});

    my $next_cursor = -1;
    while ($next_cursor = get_followed($next_cursor, $curated_feed)) { vverbose 0,"Cursor $next_cursor";}
    }

sub get_followed {
    my ($next_cursor, $curated_feed) = @_;

    # FIXME we should cache this...
    my $results = twitter_query(
      $curated_feed,
      'https://api.twitter.com/1/statuses/friends.json',
      screen_name => $curated_feed->twitter_account, # FIXME: the id, not name
      cursor => $next_cursor,
      # include_entities => 'true', # essentially, parsed last message
      # see result[].status.entities.hashtags[].text==bmoreevent, indices[] 
      # we could look at result[].statuses_count for "tweets since last time"
      );

    $next_cursor = $results->{'next_cursor'};

    foreach (@{$results->{'users'}}) {
      print $_->{'screen_name'},"\n";
      }

    return $next_cursor;
    }

sub twitter_query {
    my ($feed, $request_url, %params) = @_;

    # warn Dumper(Net::OAuth->request("protected resource")->all_params);
    my $ua = LWP::UserAgent->new;
    $ua->agent($ua->agent." ".$UserAgent);

    my $nonce = join("",map {('a'..'z','0'..'1')[rand(36)]} (1..20));
    vverbose 4,"OAuth info for ".$feed->twitter_account." ",Dumper($feed->oauth);
    my $oauth = Net::OAuth->request("protected resource")->new(
        %{$feed->oauth},
        request_method => 'GET',
        signature_method => 'HMAC-SHA1',
        timestamp => time,
        nonce => $nonce,
        extra_params => \%params,
        request_url => $request_url,
        );
    $oauth->sign;

    my $uri = URI->new($oauth->normalized_request_url);
    $uri->query_param($_ => $params{$_}) foreach keys %params;
    vverbose 4,"Going to ask $uri (from $request_url)";
    vverbose 4,"With auth header: ",$oauth->to_authorization_header;
    my $req = HTTP::Request->new(GET => $uri, [ Authorization => $oauth->to_authorization_header ]);

    my $res = $ua->request($req);

    my $data =  eval { JSON->new->decode($res->content); };
    if ($@) {
      warn "INTERNAL JSON Decode failed: $@";
      warn "Content in the http result:\n";
      warn Dumper($res->content);
      exit 1;
      }

    if ($res->is_success) {
        return $data;
        }
    else {
        # warn Dumper($res);
        die "Something went wrong: ".$res->status_line.", ".$res->message,", ".$data->{'error'};
      }

    }

main() if $0 eq __FILE__

